## 创建型
- 静态工厂 Factory
    意图：建立一个工厂类，对实现了同一接口的一些类进行实例的创建。即根据不同参数返回不同类型的实例。    
    主要解决：主要解决接口选择的问题    
    何时使用：我们明确地计划不同条件下创建不同实例时。    
    如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。    
    关键代码：创建过程在其子类执行。
    JDK: Integer.valueOf()    
    
    public interface Shape {void draw();}    
    public class Rectangle implements Shape {public void draw() {...}}    
    public class Circle implements Shape {public void draw() {...}}  
    public class Square implements Shape {public void draw() {...}}  
    public class ShapeFactory {    
        public Shape getShape(String shapeType){   
             if(shapeType.equalsIgnoreCase("CIRCLE")){return new Circle();    
             } else if(shapeType.equalsIgnoreCase("RECTANGLE")){ return new Rectangle();    
             } else if(shapeType.equalsIgnoreCase("SQUARE")){return new Square();    
             }    
             return null;
        }        
    }    
    
- 工厂方法 Factory Method
    简单工厂模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到工厂方法模式，创建一个工厂接口和创建多个工厂实现类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。如JDK Collection.iterator    
    
        public interface Sender {  public void Send();}   
        public class MailSender implements Sender {  public void Send() {...} }    
        public class SmsSender implements Sender {  public void Send() {...} }    
        
        public interface Provider {public Sender produce();  }    
        public class SendMailFactory implements Provider{ public Sender produce() { return new MailSender();  }}    
        public class SendSmsFactory implements Provider{ public Sender produce() { return new SmsSender();  }}     
        
- 抽象工厂 Abstract Factory
    工厂方法模式和抽象工厂模式不好分清楚，他们的区别如下：    
    工厂方法模式：    
    一个抽象产品类，可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类只能创建一个具体产品类的实例。    
    抽象工厂模式：    
    多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。一个抽象工厂类，可以派生出多个具体工厂类。每个具体工厂类可以创建多个具体产品类的实例，也就是创建的是一个产品线下的多个产品。  
    区别：    
    工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。 工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个。工厂方法创建 "一种" 产品，他的着重点在于"怎么创建"，也就是说如果你开发，你的大量代码很可能围绕着这种产品的构造，初始化这些细节上面。也因为如此，类似的产品之间有很多可以复用的特征，所以会和模版方法相随。抽象工厂需要创建一些列产品，着重点在于"创建哪些"产品上，也就是说，如果你开发，你的主要任务是划分不同差异的产品线，并且尽量保持每条产品线接口一致，从而可以从同一个抽象工厂继承。    
    
- 建造者 Builder
    指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。    
    主要优点如下：各个具体的建造者相互独立，有利于系统的扩展。客户端不必知道产品内部组成的细节，便于控制细节风险。    
    其缺点如下：产品的组成部分必须相同，这限制了其使用范围。如果产品的内部变化复杂，该模式会增加很多的建造者类。    
    
        class Product{    
            private String partA;private String partB;private String partC;    
            public void setPartA(String partA){this.partA=partA;}    
            public void setPartB(String partB){this.partB=partB;}  
            public void setPartC(String partC){this.partB=partC;}    
        }    
            
        abstract class Builder{    
            protected Product product=new Product();    
            public abstract void buildPartA();    
            public abstract void buildPartB();    
            public abstract void buildPartC();    
        }    
        public class ConcreteBuilder extends Builder{    
            public void buildPartA(){product.setPartA("建造 PartA");}    
            public void buildPartB(){product.setPartB("建造 PartB");}    
            public void buildPartC(){product.setPartC("建造 PartC");}    
        }
        
        class Director{    
            private Builder builder;    
            public Director(Builder builder){this.builder=builder;}   
            public Product construct(){builder.buildPartA();builder.buildPartB();builder.buildPartC();}    
        }    
                   
- 单例 Singleton
    单例对象能保证在一个JVM中，该对象只有一个实例存在。
    
        private static class Singleton{    
            private static Singleton instance = new Singleton();         
            private Singleton() { }    
            public static Singleton getInstance(){return instance}    
        }    
        
## 结构型
- 适配器 Adapter
    将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。适配器模式（Adapter）通常适用于以下场景:以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。  
    
        interface Target{public void request();}    
        class Adaptee { public void specificRequest(){...}}    
        class ObjectAdapter implements Target{    
            private Adaptee adaptee;    
            public ObjectAdapter(Adaptee adaptee){this.adaptee=adaptee;}    
            public void request(){adaptee.specificRequest();}    
        }    
        
- 组合 Compsite
- 桥接 Bridge
- 装饰 Decorator
- 外观 Facade
- 享元 Flyweight
- 代理 Proxy    
    由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。    
    
        interface Subject{void Request();}    
        class RealSubject implements Subject{public void Request(){...}}    
        class Proxy implements Subject{    
            private RealSubject realSubject=new RealSubject();    
            public void Request(){    
                preRequest();    
                realSubject.Request();    
                postRequest();    
            }    
        }    
        
## 行为型
- 命令模式 Command
- 中介/协调者 Mediator
- 观察者 Observer
- 状态模式 State
- 策略模式 Strategy
- 迭代器 Iterator
- 访问者模式 Vistor
- 模板 Template
- 责任链 Chain of Responsibility
- 备忘录模式 Memento
